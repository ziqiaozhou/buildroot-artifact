diff --git a/code32seg.c b/code32seg.c
index e829c03..b794f40 100644
--- a/code32seg.c
+++ b/code32seg.c
@@ -73,3 +73,114 @@ success:
 	/* On entry, CF=0 */
 	args->eax &= ~0xff00; /* clear ah */
 }
+
+#define SVM_EXIT_IOIO 0x07b
+#define GHCB_MSR 0xc0010130
+#define GHCB_INFO_SPECIAL_FAST_CALL     0xF01
+#define GHCB_INFO_SPECIAL_DBGPRINT      0xF03
+#define HVCALL_VTL_CALL     0x0011
+
+
+union ghcb_msr{
+	struct
+    {
+		uint32_t lower;
+		uint32_t higher;
+	};
+    struct
+    {
+		uint16_t ghcb_debug_magic;
+		uint8_t ghcb_debug_info[6];
+	};
+	struct {
+		uint64_t ghcb_info : 12;
+		uint64_t param : 20;
+		uint64_t param_high : 20;
+		uint64_t extra_data : 12;
+	};
+};
+
+static void vmgexit_keep_ghcb(union ghcb_msr * ghcb_msr)
+{
+	uint32_t orig_low, orig_high;
+	asm volatile("rdmsr"
+				 : "=a"(orig_low), "=d"(orig_high)
+				 : "c"(GHCB_MSR));
+	asm volatile("wrmsr\n\r"
+				 "rep; vmmcall\n\r" ::"c"(GHCB_MSR), "b"(0x12345678),
+				 "a"(ghcb_msr->lower), "d"(ghcb_msr->higher));
+	asm volatile("wrmsr" ::"c"(GHCB_MSR), "a"(orig_low), "d"(orig_high));
+}
+
+
+void ghcb_debug(char * buf){
+	uint8_t len = 0, l = 6, i, j;
+	union ghcb_msr ghcb_msr;
+	for (len = 0; buf[len] != 0; len++);
+	len++;
+	for (i = 0; i < len; i+=6){
+		l = ((len - i) > 6) ? 6 : (len - i);
+		ghcb_msr.lower = 0;
+		ghcb_msr.higher = 0;
+		ghcb_msr.ghcb_debug_magic = GHCB_INFO_SPECIAL_DBGPRINT;
+		for (j = 0; j < l; ++j){
+			ghcb_msr.ghcb_debug_info[j] =  buf[i+j];
+		}
+		vmgexit_keep_ghcb(&ghcb_msr);
+	}
+}
+
+void print_ghcb_msr(void){
+	uint32_t low, high; 
+	asm volatile("rdmsr"
+				 : "=a"(low), "=d"(high)
+				 : "c"(GHCB_MSR));
+	print_ghcb(low, high);
+}
+
+
+void vc_forward_vmpl0(struct biosregs *regs)
+{
+	uint32_t orig_low, orig_high;
+	union ghcb_msr ghcb_msr;
+	asm volatile("rdmsr"
+				 : "=a"(orig_low), "=d"(orig_high)
+				 : "c"(GHCB_MSR));
+	ghcb_msr.lower = 0;
+	ghcb_msr.higher = 0;
+	ghcb_msr.ghcb_info = GHCB_INFO_SPECIAL_FAST_CALL;
+	ghcb_msr.param = 2; // target VTL=2 <=> VMPL=0
+	ghcb_msr.extra_data = HVCALL_VTL_CALL;
+	
+	asm volatile("wrmsr\n\r"
+				 "rep; vmmcall\n\r" ::"c"(GHCB_MSR), "b"(SVM_EXIT_IOIO),
+				 "a"(ghcb_msr.lower), "d"(ghcb_msr.higher));
+	
+	asm volatile("\n\r" : "=a"(regs->eax),
+				 "=b"(regs->ebx),
+				 "=c"(regs->ecx),
+				 "=d"(regs->edx));
+	asm volatile("wrmsr" ::"c"(GHCB_MSR), "a"(orig_low), "d"(orig_high));
+}
+
+void print_ghcb(uint32_t low, uint32_t high){
+	char buf[22] = {0};
+	buf[0] = 'm';
+	buf[1] = 's';
+	buf[2] = 'r';
+	buf[3] = '0';
+	buf[4] = 'x';
+	uint8_t i = 0;
+	for (i = 0; i < 4; ++i)
+	{
+		buf[5 + i*2] = '0'+ ((high>> ((3-i)*8)+4) & 0xf);
+		buf[6 + i*2] = '0'+ ((high>> ((3-i)*8)) & 0xf);
+	}
+	for (i = 0; i < 4; ++i)
+	{
+		buf[13 + i*2] = '0'+ ((low>> ((3-i)*8)+4) & 0xf);
+		buf[14 + i*2] = '0'+ ((low>> ((3-i)*8)) & 0xf);
+	}
+	buf[21] = '\n';
+	ghcb_debug(buf);
+}
\ No newline at end of file
diff --git a/fw_cfg.c b/fw_cfg.c
index 4b920cf..f7a1627 100644
--- a/fw_cfg.c
+++ b/fw_cfg.c
@@ -41,6 +41,7 @@ void fw_cfg_setup(void)
 		struct fw_cfg_file *f = &files[i];
 		f->size = bswap32(f->size);
 		f->select = bswap16(f->select);
+		printf(f->name);
 	}
 }
 
@@ -104,7 +105,11 @@ void fw_cfg_dma(int control, void *buf, int len)
 	dma.address = bswap64((uintptr_t)buf);
 
 	dma_desc_addr = (uint32_t)&dma;
+	#if SUPPORT_SNP_NOREFLECT_VC
+	m_out32(FW_CFG_DMA_ADDR_LOW, bswap32(dma_desc_addr));
+	#else
 	outl(FW_CFG_DMA_ADDR_LOW, bswap32(dma_desc_addr));
+	#endif
 	while (bswap32(dma.control) & ~FW_CFG_DMA_CTL_ERROR) {
 		asm("");
 	}
@@ -115,7 +120,11 @@ void fw_cfg_read(void *buf, int len)
 	if (version & FW_CFG_VERSION_DMA) {
 		fw_cfg_dma(FW_CFG_DMA_CTL_READ, buf, len);
 	} else {
+#if SUPPORT_SNP_NOREFLECT_VC
+		m_insb(buf, FW_CFG_DATA, len);
+#else
 		insb(buf, FW_CFG_DATA, len);
+#endif
 	}
 }
 
@@ -130,7 +139,11 @@ fw_cfg_read_entry(int e, void *buf, int len)
 		fw_cfg_dma(control, buf, len);
 	} else {
 		fw_cfg_select(e);
+#if SUPPORT_SNP_NOREFLECT_VC
+		m_insb(buf, FW_CFG_DATA, len);
+#else
 		insb(buf, FW_CFG_DATA, len);
+#endif
 	}
 }
 
@@ -213,8 +226,11 @@ static void boot_pvh_from_fw_cfg(void)
 	uint32_t sz;
 	struct linuxboot_args args;
 	struct hvm_modlist_entry ramdisk_mod;
-
+#ifdef SUPPORT_SNP_NOREFLECT_VC
+	start_info.magic = SNP_NOREFLECTVC_START_MAGIC_VALUE;
+#else
 	start_info.magic = XEN_HVM_START_MAGIC_VALUE;
+#endif
 	start_info.version = 1;
 	start_info.flags = 0;
 	start_info.nr_modules = 0;
diff --git a/include/fw_cfg.h b/include/fw_cfg.h
index 1ddfc1f..11333bd 100644
--- a/include/fw_cfg.h
+++ b/include/fw_cfg.h
@@ -44,6 +44,7 @@
 #define FW_CFG_DMA_CTL_SKIP           0x04
 #define FW_CFG_DMA_CTL_SELECT         0x08
 
+#if !SUPPORT_SNP_NOREFLECT_VC
 #define FW_CFG_CTL                    0x510
 #define FW_CFG_DATA                   0x511
 #define FW_CFG_DMA_ADDR_HIGH          0x514
@@ -60,13 +61,67 @@ static inline uint32_t fw_cfg_readb(void)
 {
 	return inb(FW_CFG_DATA);
 }
+#else
+#define FW_CFG_CTL                    0x8
+#define FW_CFG_DATA                   0x0
+#define FW_CFG_DMA_ADDR_HIGH          0x10
+#define FW_CFG_DMA_ADDR_LOW           0x14
+#define FW_CFG_MMIO_BASE 0xfed50000
+
+static inline void m_outw(unsigned short port, unsigned short val)
+{
+	// little endian -> big endian
+	unsigned short *addr = port + FW_CFG_MMIO_BASE;
+	unsigned short reversed_val = ((val & 0xffff) <<8) | val>>8;
+	*addr = reversed_val;
+	asm volatile("sfence" ::: "memory");
+}
+
+static inline void m_out32(unsigned short port, unsigned val)
+{
+	unsigned short *upper_addr = port + FW_CFG_MMIO_BASE + 2;
+	unsigned short *lower_addr = port + FW_CFG_MMIO_BASE;
+	*lower_addr = val;
+	*upper_addr =  (val >> 16);
+	asm volatile("sfence" ::: "memory");
+}
+
+static inline unsigned char m_inb(unsigned short port)
+{
+	unsigned char *addr = port + FW_CFG_MMIO_BASE;
+	unsigned char ret = *addr;
+	asm volatile("lfence" ::: "memory");
+	return ret;
+}
+
+static inline void m_insb(void *buf, unsigned short port, int len)
+{
+	unsigned char val;
+	unsigned char *addr = port + FW_CFG_MMIO_BASE;
+	unsigned char *resp = buf;
+	for (size_t i = 0; i < len; i++)
+	{
+		resp[i] = m_inb(addr);
+	}
+}
+
+static inline void fw_cfg_select(uint16_t f)
+{
+	m_outw(FW_CFG_CTL, f);
+}
+
+static inline uint32_t fw_cfg_readb(void)
+{
+	return m_inb(FW_CFG_DATA);
+}
+#endif
 
 static inline uint32_t fw_cfg_readw_be(void)
 {
 	uint32_t val;
 	
-	val = inb(FW_CFG_DATA);
-	val = (val << 8) | inb(FW_CFG_DATA);
+	val = fw_cfg_readb();
+	val = (val << 8) | fw_cfg_readb();
 	return val;
 }
 
@@ -74,8 +129,8 @@ static inline uint32_t fw_cfg_readw_le(void)
 {
 	uint32_t val;
 
-	val = inb(FW_CFG_DATA);
-	val = (inb(FW_CFG_DATA) << 8) | val;
+	val = fw_cfg_readb();
+	val = (fw_cfg_readb() << 8) | val;
 	return val;
 }
 
@@ -83,10 +138,10 @@ static inline uint32_t fw_cfg_readl_be(void)
 {
 	uint32_t val;
 	
-	val = inb(FW_CFG_DATA);
-	val = (val << 8) | inb(FW_CFG_DATA);
-	val = (val << 8) | inb(FW_CFG_DATA);
-	val = (val << 8) | inb(FW_CFG_DATA);
+	val = fw_cfg_readb();
+	val = (val << 8) | fw_cfg_readb();
+	val = (val << 8) | fw_cfg_readb();
+	val = (val << 8) | fw_cfg_readb();
 	return val;
 }
 
@@ -94,17 +149,17 @@ static inline uint32_t fw_cfg_readl_le(void)
 {
 	uint32_t val;
 
-	val = inb(FW_CFG_DATA);
-	val = (inb(FW_CFG_DATA) << 8) | val;
-	val = (inb(FW_CFG_DATA) << 16) | val;
-	val = (inb(FW_CFG_DATA) << 24) | val;
+	val = fw_cfg_readb();
+	val = (fw_cfg_readb() << 8) | val;
+	val = (fw_cfg_readb() << 16) | val;
+	val = (fw_cfg_readb() << 24) | val;
 	return val;
 }
 
 static inline void fw_cfg_skip(int len)
 {
 	while (len--)
-		inb(FW_CFG_DATA);
+		fw_cfg_readb();
 }
 
 void fw_cfg_setup(void);
diff --git a/include/start_info.h b/include/start_info.h
index 348779e..fe6ffdf 100644
--- a/include/start_info.h
+++ b/include/start_info.h
@@ -101,7 +101,7 @@
  *              before trying to read the memory map.
  */
 #define XEN_HVM_START_MAGIC_VALUE 0x336ec578
-
+#define SNP_NOREFLECTVC_START_MAGIC_VALUE 0xbed2bade
 /*
  * C representation of the x86/HVM start info layout.
  *
diff --git a/main.c b/main.c
index afa2200..a1ba9e7 100644
--- a/main.c
+++ b/main.c
@@ -84,22 +84,27 @@ int __attribute__ ((section (".text.startup"))) main(void)
 	outb(FW_EXIT_PORT, FW_START);
 #endif
 	have_pci = setup_hw();
-
 	// Only the 16-bit trampoline for vmlinuz and the 16-bit interrupt
 	// handlers need to run from the F-segment, but keep things simple
 	// and jump there.  From this point we can modify global variables.
 	asm("ljmp $0x8, $1f; 1:");
 
+#if !SUPPORT_SNP_NOREFLECT_VC
 	have_mmconfig = setup_mmconfig();
 	if (have_pci) {
+		printf("setup_pci");
 		setup_pci();
 	}
+#endif
 	setup_idt();
+	printf("fw_cfg_setup");
 	fw_cfg_setup();
 	extract_acpi();
+	printf("extract_e820");
 	extract_e820();
 	setup_mptable();
 	extract_smbios();
+	printf("boot_from_fwcfg");
 	boot_from_fwcfg();
 	panic();
 }
diff --git a/meson.build b/meson.build
index d060f75..97f6edc 100644
--- a/meson.build
+++ b/meson.build
@@ -13,6 +13,7 @@ c_args = [
   '-mstringop-strategy=rep_byte',
   '-minline-all-stringops',
   '-fno-pic',
+  '-DSUPPORT_SNP_NOREFLECT_VC=1',
 ]
 
 link_args = ['-nostdlib', '-m32']
diff --git a/mptable.c b/mptable.c
index 6d62cef..f843117 100644
--- a/mptable.c
+++ b/mptable.c
@@ -85,7 +85,7 @@ void setup_mptable(void)
 
 	fw_cfg_select(FW_CFG_NB_CPUS);
 	num_cpus = fw_cfg_readl_le();
-	mptable_get_cpuid(&cpuid_stepping, &cpuid_features);
+	//mptable_get_cpuid(&cpuid_stepping, &cpuid_features);
 
 	for (i = 0; i < num_cpus; i++) {
 		cpu = (struct mpc_cpu *) (MPTABLE_START + offset);
@@ -97,8 +97,8 @@ void setup_mptable(void)
 		if (i == 0) {
 			cpu->cpuflag |= CPU_BOOTPROCESSOR;
 		}
-		cpu->cpufeature = cpuid_stepping;
-		cpu->featureflag = cpuid_features;
+		//cpu->cpufeature = cpuid_stepping;
+		//cpu->featureflag = cpuid_features;
 		checksum += mptable_checksum((char *) cpu, ssize);
 		offset += ssize;
 	}
diff --git a/printf.c b/printf.c
index bfbd15c..66448c6 100644
--- a/printf.c
+++ b/printf.c
@@ -27,9 +27,11 @@ static void addchar(pstream_t *p, char c)
 int puts(const char *c)
 {
     int n = 0;
-    while (c[n])
-        outb(0x3f8, c[n++]);
-    return n;
+	return n;
+	
+	while (c[n])
+		outb(0x3f8, c[n++]);
+	return n;
 }
 
 void print_str(pstream_t *p, const char *s, strprops_t props)
@@ -248,6 +250,7 @@ int printf(const char *fmt, ...)
     va_start(va, fmt);
     r = vsnprintf(buf, sizeof buf, fmt, va);
     va_end(va);
-    puts(buf);
+	ghcb_debug(buf);
+    //puts(buf);
     return r;
 }
